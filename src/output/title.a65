; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.0 [2023/11/24] for 6502
; ------------------------------------------------------------

STACKWIDTH	= 16
CODEORIGIN	= $0C00

TRUE		= 1
FALSE		= 0

; ------------------------------------------------------------

	org $80

zpage

.if .def(@vbxe_detect)
fxptr	.ds 2						; VBXE pointer
.fi

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

	.ifdef MAIN.@DEFINES.BASICOFF
	org CODEORIGIN
	icl 'atari\basicoff.asm'
	ini CODEORIGIN
	.fi

	.ifdef MAIN.@DEFINES.S_VBXE
	opt h-
	ins 'atari\s_vbxe\sdxld2.obx'
	opt h+
	.fi

	org CODEORIGIN

.local	MAIN.@RESOURCE
.endl

.local	RESOURCE
	icl 'atari\resource.asm'
	?EXTDETECT = 0
	?VBXDETECT = 0

	DOSFILE '../assets/title.xex' XEX_ADDRESS 0 0 0 0 0 0 0 0
.endl

; ------------------------------------------------------------

	org CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_a8.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

	.ifdef MAIN.@DEFINES.ROMOFF
	icl 'atari\romoff.asm'
	.fi

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift VADR > $BFFF
	ert 'Invalid memory address range ',VADR
	eli (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$0F					; DOS II+/D ParamStr
	mva:rpl $340,x MAIN.IOCB@COPY,x-

	inx						; X = 0
	stx bp						; BP = 0

	stx audctl					; reset POKEY
	stx audctl+$10
	lda #3
	sta skctl
	sta skctl+$10

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_007A

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

.local	DPEEK						; FUNCTION | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta A
	lda :STACKORIGIN+STACKWIDTH,x
	sta A+1
	dex
@main

; -------------------  ASM Block 00000003  -------------------

	ldy #0
	mva (:edx),y Result
	iny
	mva (:edx),y Result+1

@exit

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

A	= :EDX
RESULT	= :STACKORIGIN-4
	rts						; ret
.endl

.local	MOVE_00BE					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER | INLINE

	.MACRO m@INLINE

; -------------------  ASM Block 00000035  -------------------

	jsr @move

	.ENDM

; ------------------------------------------------------------

SOURCE	= :EDX
DEST	= :ECX
COUNT	= :EAX
@exit
.endl

; ------------------------------------------------------------

__PORTB_BANKS	= $0101
M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
MGTIA	= $00
MVBXE	= $80
VBXE_XDLADR	= $00
VBXE_BCBTMP	= $E0
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_CHBASE	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $00
IVBL	= $01
IVBLD	= $01
IVBLI	= $02
ITIM1	= $03
ITIM2	= $04
ITIM4	= $05
CH_DELCHR	= $FE
CH_ENTER	= $9B
CH_ESC	= $1B
CH_CURS_UP	= $1C
CH_CURS_DOWN	= $1D
CH_CURS_LEFT	= $1E
CH_CURS_RIGHT	= $1F
CH_TAB	= $7F
CH_EOL	= $9B
CH_CLR	= $7D
CH_BELL	= $FD
CH_DEL	= $7E
CH_DELLINE	= $9C
CH_INSLINE	= $9D
PAL_PMCOLOR0	= $00
PAL_PMCOLOR1	= $01
PAL_PMCOLOR2	= $02
PAL_PMCOLOR3	= $03
PAL_COLOR0	= $04
PAL_COLOR1	= $05
PAL_COLOR2	= $06
PAL_COLOR3	= $07
PAL_COLBAK	= $08
COLOR_BLACK	= $00
COLOR_WHITE	= $0E
COLOR_RED	= $32
COLOR_CYAN	= $96
COLOR_VIOLET	= $68
COLOR_GREEN	= $C4
COLOR_BLUE	= $74
COLOR_YELLOW	= $EE
COLOR_ORANGE	= $28
COLOR_BROWN	= $E4
COLOR_LIGHTRED	= $3C
COLOR_GRAY1	= $04
COLOR_GRAY2	= $06
COLOR_GRAY3	= $0A
COLOR_LIGHTGREEN	= $CC
COLOR_LIGHTBLUE	= $7C
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
DATESEPARATOR	= DATAORIGIN+$0004
RND	= $D20A
adr.PALETTE	= $02C0
.var PALETTE	= adr.PALETTE .word
adr.HPALETTE	= $D012
.var HPALETTE	= adr.HPALETTE .word
FILEMODE	= DATAORIGIN+$0005
GRAPHMODE	= DATAORIGIN+$0006
IORESULT	= DATAORIGIN+$0007
EOLN	= DATAORIGIN+$0008
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	ATARI						; UNIT

; ------------------------------------------------------------

IRQENS	= $10
RTCLOK	= $12
RTCLOK1	= $12
RTCLOK2	= $13
RTCLOK3	= $14
ATRACT	= $4D
LMARGIN	= $52
RMARGIN	= $53
ROWCRS	= $54
COLCRS	= $55
DINDEX	= $57
SAVMSC	= $58
PALNTS	= $62
RAMTOP	= $6A
VDSLST	= $0200
SDLSTL	= $0230
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
FILDAT	= $02FD
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
COLBAKS	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
P0PF	= $D004
PAL	= $D014
TRIG3	= $D013
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
KBCODE	= $D209
IRQEN	= $D20E
SKSTAT	= $D20F
PORTA	= $D300
PORTB	= $D301
PACTL	= $D302
DMACTL	= $D400
CHACTL	= $D401
DLISTL	= $D402
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIVEC	= $FFFA
RESETVEC	= $FFFC
IRQVEC	= $FFFE

.endl							; UNIT ATARI

; ------------------------------------------------------------

.local	JOYSTICK					; UNIT

; ------------------------------------------------------------

JOY_NONE	= $0F
JOY_UP	= $0E
JOY_DOWN	= $0D
JOY_LEFT	= $0B
JOY_LEFT_UP	= $0A
JOY_LEFT_DOWN	= $09
JOY_RIGHT	= $07
JOY_RIGHT_UP	= $06
JOY_RIGHT_DOWN	= $05
JOY_1	= $0278
JOY_2	= $0279
adr.STICK	= $0278
.var STICK	= adr.STICK .word
STICK0	= $0278
STICK1	= $0279
adr.STRIG	= $0284
.var STRIG	= adr.STRIG .word
STRIG0	= $0284
STRIG1	= $0285
adr.PADDL	= $0270
.var PADDL	= adr.PADDL .word
PADDL0	= $0270
PADDL1	= $0271
PADDL2	= $0272
PADDL3	= $0273
PADDL4	= $0274
PADDL5	= $0275
PADDL6	= $0276
PADDL7	= $0277
adr.PTRIG	= $027C
.var PTRIG	= adr.PTRIG .word
PTRIG0	= $027C
PTRIG1	= $027D
PTRIG2	= $027E
PTRIG3	= $027F
PTRIG4	= $0280
PTRIG5	= $0281
PTRIG6	= $0282
PTRIG7	= $0283
TRIG0	= $D010
TRIG1	= $D011
POT0	= $D200
ALLPOT	= $D208
POTGO	= $D20B

.endl							; UNIT JOYSTICK

; ------------------------------------------------------------

.local	MATH						; UNIT

; ------------------------------------------------------------

.endl							; UNIT MATH

; ------------------------------------------------------------

.local	PMG						; UNIT

; ------------------------------------------------------------

_P_MAX	= $0E
_M0_MAX	= $02
_M1_MAX	= $00
_M2_MAX	= $03
_M3_MAX	= $04
_PM_NORMAL_SIZE	= $00
_PM_DOUBLE_SIZE	= $01
_PM_QUAD_SIZE	= $03
_PM_SHOW_ON	= $03
_PM_SHOW_OFF	= $00
_PM_DOUBLE_RES	= $01
_PM_SINGLE_RES	= $02
adr.P_DATA	= [DATAORIGIN+$000B] .array [4] .word
.var P_DATA	= adr.P_DATA .word
adr.M_DATA	= [DATAORIGIN+$0013] .array [4] .word
.var M_DATA	= adr.M_DATA .word
PM_MEM	= DATAORIGIN+$001B
PM_OFFSET	= DATAORIGIN+$001D
PM_TOP	= DATAORIGIN+$001F
PM_SIZE	= DATAORIGIN+$0020

.endl							; UNIT PMG

; ------------------------------------------------------------

.local	XBIOS						; UNIT

.local	XBIOSLOADFILE					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000062  -------------------


    txa:pha
    mva #0 xBiosIOresult
    sta xBiosIOerror
    ldy filename
    ldx filename+1
    iny
    sne
    inx
    jsr xBIOS_LOAD_FILE
    bcc @+
    stx xBiosIOerror
    mva #1 xBiosIOresult 
@   pla:tax

; ------------------------------------------------------------

FILENAME	= DATAORIGIN+$0028

@VarData	= FILENAME
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	XBIOSOPENFILE					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000063  -------------------


    txa:pha
    mva #0 xBiosIOresult
    sta xBiosIOerror
    ldy filename
    ldx filename+1
    iny
    sne
    inx
    jsr xBIOS_OPEN_FILE
    bcc @+
    stx xBiosIOerror
    mva #1 xBiosIOresult 
@   pla:tax

; ------------------------------------------------------------

FILENAME	= DATAORIGIN+$002A

@VarData	= FILENAME
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

XBIOSIORESULT	= DATAORIGIN+$0022
XBIOSIOERROR	= DATAORIGIN+$0023
XBIOSDIRENTRYINDEX	= DATAORIGIN+$0024
XBIOSDIRENTRYSTATUS	= DATAORIGIN+$0025
XBIOSDIRENTRYSECTOR	= DATAORIGIN+$0026
XBIOS_ADDRESS	= $0800
XBIOS_VERSION	= $0802
XBIOS_RENAME_ENTRY	= $0803
XBIOS_LOAD_FILE	= $0806
XBIOS_OPEN_FILE	= $0809
XBIOS_LOAD_DATA	= $080C
XBIOS_WRITE_DATA	= $080F
XBIOS_OPEN_CURRENT_DIR	= $0812
XBIOS_GET_BYTE	= $0815
XBIOS_PUT_BYTE	= $0818
XBIOS_FLUSH_BUFFER	= $081B
XBIOS_SET_LENGTH	= $081E
XBIOS_SET_INIAD	= $0821
XBIOS_SET_FILE_OFFSET	= $0824
XBIOS_SET_RUNAD	= $0827
XBIOS_SET_DEFAULT_DEVICE	= $082A
XBIOS_OPEN_DIR	= $082D
XBIOS_LOAD_BINARY_FILE	= $0830
XBIOS_OPEN_DEFAULT_DIR	= $0833
XBIOS_SET_DEVICE	= $0836
XBIOS_RELOCATE_BUFFER	= $0839
XBIOS_GET_ENTRY	= $083C
XBIOS_OPEN_DEFAULT_FILE	= $083F
XBIOS_READ_SECTOR	= $0842
XBIOS_FIND_ENTRY	= $0845
XBIOS_SET_BUFFER_SIZE	= $0848
XDIRSIZE	= $0BE5
XSPEED	= $0BE6
XHSPEED	= $0BE7
XIRQEN	= $0BE8
XAUDCTL	= $0BE9
XFILE	= $0BEA
XDIR	= $0BEC
XIOV	= $0BEE
XBUFFERH	= $0BF0
XBUFSIZE	= $0BF1
XDAUX3	= $0BF2
XSEGMENT	= $0BF3
XNOTE	= $0BF5
XNOTEH	= $0BF7
XDEVICE	= $0BFC
XDCMD	= $0BFD
XDAUX1	= $0BFE
XDAUX2	= $0BFF

.endl							; UNIT XBIOS

; ------------------------------------------------------------

.local	XBAPLIB						; UNIT

.local	XBUNAPL						; PROCEDURE

; optimize OK (XBAPLIB), line = 43

	lda FNAM
	sta XBIOS.XBIOSOPENFILE.FILENAME
	lda FNAM+1
	sta XBIOS.XBIOSOPENFILE.FILENAME+1
	jsr XBIOS.XBIOSOPENFILE

; -------------------  ASM Block 00000086  -------------------

		stx @sp

		mwa outputPointer dest_ap

//		mva #$00 GET_BYTE+1

aPL_depack	lda #$80
		sta token
literal		lsr bl
		jsr xbios.xBIOS_GET_BYTE
write		jsr store
nxt_token	jsr get_token_bit
		bcc literal		; literal  -> 0
		jsr get_token_bit
		bcc block		; block    -> 10
		jsr get_token_bit
		bcc short_block		; short block -> 110

single_byte	lsr bl			; single byte -> 111
		lda #$10
@		pha
		jsr get_token_bit
		pla
		rol @
		bcc @-
		beq write
		jmp len01

aPL_done	jmp to_exit

short_block	jsr xbios.xBIOS_GET_BYTE
		lsr @
		beq aPL_done
		sta EBPL
		ldx #0
		stx EBPH
		ldx #$02
		bcc @+
		inx
@		sec
		ror  bl
		jmp len0203

block		jsr getgamma
		dex
		lda #$ff
bl		equ *-1
		bmi normalcodepair
		dex
		bne normalcodepair
		jsr getgamma
		lda #$ff
EBPL		equ *-1
		sta offsetL
		lda #$ff
EBPH		equ *-1
		sta offsetH
		jmp lenffff

normalcodepair	dex
		stx    offsetH
		stx    EBPH
		jsr    xbios.xBIOS_GET_BYTE
		sta    offsetL
		sta    EBPL
		jsr    getgamma
		lda    offsetH
		beq    _ceck7f
		cmp    #$7d
		bcs	 plus2
		cmp    #$05
		bcs	 plus1
		bcc    normal1               ; zawsze
_ceck7f		lda	 offsetL
		bmi    normal1
plus2		inx
		bne    plus1
		iny
plus1		inx
normal1
lenffff		iny
		sec
		ror bl
		bne domatch	; zawsze

getgamma	lda #$00
		pha
		lda #$01
		pha
@		jsr get_token_bit
		tsx
		rol $101,x
		rol $102,x
		jsr get_token_bit
		bcs @-
		pla
		tax
		pla
		tay
		rts

get_token_bit	asl    token
		bne    @+
		php
		jsr    xbios.xBIOS_GET_BYTE
		plp
		rol    @
		sta    token
@		rts
token		.byte $00

store		sta $ffff
dest_ap		equ *-2
		inw dest_ap
		rts

len01		ldx    #$01
len0203		ldy    #$00
		sta    offsetL
		sty    offsetH
		iny

domatch		lda dest_ap
		sec
		sbc #$ff
offsetL		equ *-1
		sta src
		lda dest_ap+1
		sbc #$ff
offsetH		equ *-1
		sta src+1
source		lda $ffff
src		equ *-2
		inw src
		jsr store
		dex
		bne source
		dey
		bne source
		jmp nxt_token


to_exit		lda #0
		tya
		sta:rne @buf,y+

		ldx @sp: #0

; ------------------------------------------------------------

FNAM	= DATAORIGIN+$002C
OUTPUTPOINTER	= DATAORIGIN+$002E

@VarData	= FNAM
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

.endl							; UNIT XBAPLIB

; ------------------------------------------------------------

.local	CRT						; UNIT

.local	DELAY						; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000090  -------------------

	txa:pha

	ldx #0
	ldy #0

loop	cpy count
	bne @+
	cpx count+1
	beq stop

@	:8 lda:cmp:req vcount

	iny
	sne
	inx

	bne loop

stop	pla:tax

; ------------------------------------------------------------

COUNT	= DATAORIGIN+$0031

@VarData	= COUNT
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

TEXTATTR	= DATAORIGIN+$0030
CONSOL	= $D01F
CN_START_SELECT_OPTION	= $00
CN_SELECT_OPTION	= $01
CN_START_OPTION	= $02
CN_OPTION	= $03
CN_START_SELECT	= $04
CN_SELECT	= $05
CN_START	= $06
CN_NONE	= $07
BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLACK	= $00
WHITE	= $0F
RED	= $26
CYAN	= $AC
PURPLE	= $48
GREEN	= $B6
BLUE	= $86
YELLOW	= $DC
ORANGE	= $18
BROWN	= $F4
LIGHT_RED	= $2A
DARK_GREY	= $04
GREY	= $08
LIGHT_GREEN	= $BC
LIGHT_BLUE	= $9A
LIGHT_GREY	= $0C
BLINK	= $80

.endl							; UNIT CRT

; ------------------------------------------------------------

.local	CIO						; UNIT

; ------------------------------------------------------------

.endl							; UNIT CIO

; ------------------------------------------------------------

.local	APLIB						; UNIT

; ------------------------------------------------------------

.endl							; UNIT APLIB

; ------------------------------------------------------------

.local	B_UTILS						; UNIT

; ------------------------------------------------------------

BASE64CHARS	= DATAORIGIN+$0033
adr.BASE64INV	= [DATAORIGIN+$0035] .array [128]
.var BASE64INV	= adr.BASE64INV .word

.endl							; UNIT B_UTILS

; ------------------------------------------------------------

.local	MISC						; UNIT

.local	DETECTANTIC					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000112  -------------------


// ANTIC PAL Test for Atari 8-bits
// (C) 2019 Guillermo Fuenzalida

antic_loop1
	lda vcount
	cmp #100
	bcc antic_loop1		// wait till scanline 200
	sta scanline
antic_loop2
	lda vcount
	cmp #10
	bmi antic_loop2_fin
	cmp scanline
	bmi antic_loop2
	sta scanline
	bpl antic_loop2

antic_loop2_fin
	ldy #$00
	lda #0
scanline equ *-1
	cmp #135
	bmi ntsc
	iny
ntsc
	sty Result


@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$00B5
	rts						; ret
.endl

; ------------------------------------------------------------

adr.BANKS	= $0101
.var BANKS	= adr.BANKS .word
DETECTOS	= $FFF7

.endl							; UNIT MISC

; ------------------------------------------------------------

.local	RMT						; UNIT

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; optimize FAIL ('MISC.DETECTANTIC', RMT), line = 175

	jsr MISC.DETECTANTIC
	lda MISC.DETECTANTIC.RESULT
	jeq l_017C

; optimize OK (RMT), line = 176

	lda #$00
	jmp l_018A
l_017C

; optimize OK (RMT), line = 178

	lda #$04
l_018A
	sta NTSC

	rts

; ------------------------------------------------------------

NTSC	= DATAORIGIN+$00B6

.endl							; UNIT RMT

; ------------------------------------------------------------

.local	B_PMG						; UNIT

; ------------------------------------------------------------

PMG_VDELAY_M0	= $01
PMG_VDELAY_M1	= $02
PMG_VDELAY_M2	= $04
PMG_VDELAY_M3	= $08
PMG_VDELAY_P0	= $10
PMG_VDELAY_P1	= $20
PMG_VDELAY_P2	= $40
PMG_VDELAY_P3	= $80
PMG_SIZE_NORMAL	= $00
PMG_SIZE_X2	= $01
PMG_SIZE_X4	= $03
PMG_MSIZE0_X2	= $01
PMG_MSIZE0_X4	= $03
PMG_MSIZE1_X2	= $04
PMG_MSIZE1_X4	= $0C
PMG_MSIZE2_X2	= $10
PMG_MSIZE2_X4	= $30
PMG_MSIZE3_X2	= $40
PMG_MSIZE4_X4	= $C0
PMG_GRACTL_MISSILES	= $01
PMG_GRACTL_PLAYERS	= $02
PMG_GRACTL_LATCH	= $04
PMG_GRACTL_DEFAULT	= $03
PMG_SDMCTL_DMA_MISSILE	= $04
PMG_SDMCTL_DMA_PLAYER	= $08
PMG_SDMCTL_DMA_BOTH	= $0C
PMG_SDMCTL_ONELINE	= $10
PMG_SDMCTL_SCREEN_DISABLED	= $00
PMG_SDMCTL_SCREEN_NARROW	= $01
PMG_SDMCTL_SCREEN_NORMAL	= $02
PMG_SDMCTL_SCREEN_WIDE	= $03
PMG_SDMCTL_DEFAULT	= $0E
PMG_COLLISION_PLAYER_TO_P0	= $01
PMG_COLLISION_PLAYER_TO_P1	= $02
PMG_COLLISION_PLAYER_TO_P2	= $04
PMG_COLLISION_PLAYER_TO_P3	= $08
PMG_5PLAYER	= $10
PMG_OVERLAP	= $20
PMG_SDMCTL	= $D400
PMG_SDMCTL_S	= $022F
PMG_GPRIOR	= $D01B
PMG_GPRIOR_S	= $026F
PMG_PCOLR0	= $D012
PMG_PCOLR1	= $D013
PMG_PCOLR2	= $D014
PMG_PCOLR3	= $D015
adr.PMG_PCOLR	= $D012
.var PMG_PCOLR	= adr.PMG_PCOLR .word
PMG_PCOLR0_S	= $02C0
PMG_PCOLR1_S	= $02C1
PMG_PCOLR2_S	= $02C2
PMG_PCOLR3_S	= $02C3
adr.PMG_PCOLR_S	= $02C0
.var PMG_PCOLR_S	= adr.PMG_PCOLR_S .word
PMG_HPOS0	= $D000
PMG_HPOS1	= $D001
PMG_HPOS2	= $D002
PMG_HPOS3	= $D003
adr.PMG_HPOS	= $D000
.var PMG_HPOS	= adr.PMG_HPOS .word
PMG_HPOSM0	= $D004
PMG_HPOSM1	= $D005
PMG_HPOSM2	= $D006
PMG_HPOSM3	= $D007
adr.PMG_HPOSM	= $D004
.var PMG_HPOSM	= adr.PMG_HPOSM .word
PMG_SIZEP0	= $D008
PMG_SIZEP1	= $D009
PMG_SIZEP2	= $D00A
PMG_SIZEP3	= $D00B
adr.PMG_SIZEP	= $D008
.var PMG_SIZEP	= adr.PMG_SIZEP .word
PMG_SIZEM	= $D00C
PMG_GRAFP0	= $D00D
PMG_GRAFP1	= $D00E
PMG_GRAFP2	= $D00F
PMG_GRAFP3	= $D010
adr.PMG_GRAFP	= $D00D
.var PMG_GRAFP	= adr.PMG_GRAFP .word
PMG_GRAFM	= $D011
PMG_P0PL	= $D00C
PMG_P1PL	= $D00D
PMG_P2PL	= $D00E
PMG_P3PL	= $D00F
adr.PMG_PPL	= $D00C
.var PMG_PPL	= adr.PMG_PPL .word
PMG_VDELAY	= $D01C
PMG_GRACTL	= $D01D
PMG_HITCLR	= $D01E
PMG_PMBASE	= $D407
PMG_ONELINE	= DATAORIGIN+$00C7
PMG_BASE	= DATAORIGIN+$00C8
PMG_SIZE	= DATAORIGIN+$00CA

.endl							; UNIT B_PMG

; ------------------------------------------------------------

.local	DOS						; UNIT

; ------------------------------------------------------------

PALNTSC	= $D014

.endl							; UNIT DOS

; ------------------------------------------------------------

.local	STRUTILS					; UNIT

; ------------------------------------------------------------

.endl							; UNIT STRUTILS

; ------------------------------------------------------------

.local	SYSUTILS					; UNIT

; ------------------------------------------------------------

FAREADONLY	= $01
FAHIDDEN	= $02
FASYSFILE	= $04
FAVOLUMEID	= $08
FADIRECTORY	= $10
FAARCHIVE	= $20
FAANYFILE	= $3F

.endl							; UNIT SYSUTILS

; ------------------------------------------------------------

.local	B_SYSTEM					; UNIT

; ------------------------------------------------------------

__NMIEN	= DATAORIGIN+$00CC
PORTB_SELFTEST_OFF	= $80
PORTB_BASIC_OFF	= $02
PORTB_SYSTEM_ON	= $01

.endl							; UNIT B_SYSTEM

; ------------------------------------------------------------

.local	B_CRT						; UNIT

.local	CRT_WRITE_01CD					; PROCEDURE | OVERLOAD

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$00
	mva:rne (:bp2),y adr.S,y+
	mwa #adr.S S
	dex
@main

; optimize OK (B_CRT), line = 531

	lda adr.S
	sta SYSTEM.MOVE_00BE.COUNT
	lda <adr.S+$01
	sta SYSTEM.MOVE_00BE.SOURCE
	lda >adr.S+$01
	sta SYSTEM.MOVE_00BE.SOURCE+1
	lda CRT_CURSOR
	sta SYSTEM.MOVE_00BE.DEST
	lda CRT_CURSOR+1
	sta SYSTEM.MOVE_00BE.DEST+1
	lda #$00
	sta SYSTEM.MOVE_00BE.COUNT+1
	.LOCAL +MAIN.SYSTEM.MOVE_00BE
	m@INLINE
	.ENDL

; optimize OK (B_CRT), line = 532

	lda adr.S
	add CRT_CURSOR
	sta CRT_CURSOR
	lda CRT_CURSOR+1
	adc #$00
	sta CRT_CURSOR+1

; ------------------------------------------------------------

adr.S	= [DATAORIGIN+$00D6] .array [256]
.var S	= adr.S .word

@VarData	= S
@VarDataSize	= 256

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

DEFAULT_SCREENWIDTH	= $28
DEFAULT_SCREENHEIGHT	= $18
CHAR_RETURN	= $9B
CHAR_ESCAPE	= $1B
CHAR_BACKSPACE	= $7E
CHAR_TAB	= $7F
CHAR_INVERSE	= $81
CHAR_CAPS	= $82
ICHAR_RETURN	= $DB
ICHAR_ESCAPE	= $5B
ICHAR_BACKSPACE	= $7E
ICHAR_TAB	= $7F
ICHAR_INVERSE	= $C1
ICHAR_CAPS	= $C2
adr.CRT_KEYCODE	= CODEORIGIN+$0076
.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
CRT_VRAM	= DATAORIGIN+$00CD
CRT_SIZE	= DATAORIGIN+$00CF
CRT_SCREENWIDTH	= DATAORIGIN+$00D1
CRT_SCREENHEIGHT	= DATAORIGIN+$00D2
CRT_CURSOR	= DATAORIGIN+$00D3
CRT_LEFTMARGIN	= DATAORIGIN+$00D5
KBCODE	= $D209
CONSOL	= $D01F

.endl							; UNIT B_CRT

.local	DLI_MAP						; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000158  -------------------


dli:
    phr ; store registers

dlijmp:
    jmp dli1

dli1:
    lda #>MAP_FNT_ADDRESS
    sta $D409 ; CHBAS_real
    sta WSYNC

    mva #$0e atari.colpf0
    mva #$06 atari.colpf1
    mva #$88 atari.colpf2
    mva #$2a atari.colpf3
    mva #$00 atari.colbk

    ; move PMG to current position
    lda PLAYERPOS_X
    sta HPOSP0
    sta HPOSP1
    sta HPOSP2
    sta HPOSP3

    lda #<dli2
    sta dlijmp+1
    lda #>dli2
    sta dlijmp+2

    plr
    rti

dli2:
    mva #$ff atari.colpf1 ; lum
    mva #$00 atari.colpf2 ; hue

    lda #>MAINFONT_ADR
    sta $D409 ; CHBAS_real

    ; deactivate PMG by moving it out of screen
    lda #$0
    sta HPOSP0
    sta HPOSP1
    sta HPOSP2
    sta HPOSP3
    sta WSYNC

    ; next
    lda #<dli3
    sta dlijmp+1
    lda #>dli3
    sta dlijmp+2

    plr
    rti

dli3:
    sta WSYNC
    mva #$ff atari.colpf1 ; lum
    mva #$00 atari.colpf2 ; hue

    lda #<dli1
    sta dlijmp+1
    lda #>dli1
    sta dlijmp+2

    plr
    rti

	rti						; ret
.endl

.local	DLI_BLACK_CONSOLE				; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000159  -------------------


    phr ; store registers
    mva #$0 atari.colpf0                 ;---- outline color
    mva #$0 atari.colpf1                ;---- dark color
    mva #$0 atari.colpf2                ;---- face shadow color
    mva #$0 atari.colbk                 ;---- back color
    plr                                  ;---- restore registers

	rti						; ret
.endl

.local	DLI_CONSOLE					; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000160  -------------------


    phr ; store registers
    mva loccolbk atari.colbk
    mva loccolpf0 atari.colpf0                 ;---- outline color
    mva loccolpf1 atari.colpf1                 ;---- outline color
    mva loccolpf2 atari.colpf2                 ;---- outline color
    plr                                  ;---- restore registers

	rti						; ret
.endl

.local	SHOW_LOGO					; PROCEDURE

; optimize OK (title.pas), line = 55

	lda #$51
	sta XBAPLIB.XBUNAPL.FNAM
	lda #$0C
	sta XBAPLIB.XBUNAPL.FNAM+1
	lda #$36
	sta XBAPLIB.XBUNAPL.OUTPUTPOINTER
	lda #$80
	sta XBAPLIB.XBUNAPL.OUTPUTPOINTER+1
	jsr XBAPLIB.XBUNAPL

; optimize OK (title.pas), line = 56

	lda #$9C
	sta ATARI.COLOR1

; optimize OK (title.pas), line = 57

	lda #$12
	sta ATARI.COLOR2

; optimize OK (title.pas), line = 58

	sta ATARI.COLOR4

; optimize OK (title.pas), line = 59

	lda #$36
	sta ATARI.SDLSTL
	lda #$80
	sta ATARI.SDLSTL+1

; optimize OK (title.pas), line = 60

	lda #$50
	sta ATARI.SAVMSC
	lda #$81
	sta ATARI.SAVMSC+1
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_007A

; optimize OK (title.pas), line = 68

	lda #$22
	sta ATARI.DMACTL

; -------------------  ASM Block 00000161  -------------------

;
    pha
    jsr xbios.xBIOS_SET_DEFAULT_DEVICE
    lda #$00
    sta xbios.xIRQEN
    pla

; optimize OK (title.pas), line = 79

	lda $0800
	sta CS
	lda $0800+1
	sta CS+1

; optimize OK (title.pas), line = 80

	lda CS
	cmp #$78
	jne l_0237x
	lda CS+1
	cmp #$42
	jeq l_0237
l_0237x

; --- RepeatUntilProlog
l_0239

; optimize FAIL ('B_CRT.CRT_WRITE_01CD', title.pas), line = 83

	inx
	mva #$5E :STACKORIGIN,x
	mva #$0C :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE_01CD

; optimize OK (title.pas), line = 84

	jmp l_0239
l_0237

; optimize FAIL ('SHOW_LOGO', title.pas), line = 86

	jsr SHOW_LOGO

; optimize OK (title.pas), line = 89

	lda #$B8
	sta CRT.DELAY.COUNT
	lda #$0B
	sta CRT.DELAY.COUNT+1
	jsr CRT.DELAY

; -------------------  ASM Block 00000162  -------------------

  jsr $5000

	ldy #256-12
	mva:rne CODEORIGIN+$0069+12-256,y adr.FINALFNAME+12-256,y+

; optimize OK (title.pas), line = 96

	lda FINALFNAME
	sta XBIOS.XBIOSLOADFILE.FILENAME
	lda FINALFNAME+1
	sta XBIOS.XBIOSLOADFILE.FILENAME+1
	jsr XBIOS.XBIOSLOADFILE

; ------------------------------------------------------------

BASEADDRESS	= $BE80
E7ADR	= $E700
STICK	= $0278
PCOLR0	= $D012
PCOLR1	= $D013
PCOLR2	= $D014
PCOLR3	= $D015
PLAYERPOS_X	= $EAB8
LOCCOLBK	= $C798
LOCCOLPF0	= $C799
LOCCOLPF1	= $C79A
LOCCOLPF2	= $C79B
TXT_ADDRESS	= $C800
MAINFONT_ADR	= $CC00
PMG_BASE_ADR	= $D800
MAP_FNT_ADDRESS	= $F000
MAP_SCR_ADDRESS	= $F400
LOC_MAP_ADR	= $F800
DL_CONSOLE_ADR	= $FC00
DL_BLACK_CONSOLE_ADR	= $FC40
DL_MAP_ADR	= $FC80
XEX_ADDRESS	= $1FFA
CONSOLESTATE	= DATAORIGIN+$01D6
adr.D_LOGO	= CODEORIGIN+$0051
.var D_LOGO	= adr.D_LOGO .word
ADR_LOGO	= $8036
ADR_LOGO_DL	= $8036
ADR_LOGO_GFX	= $8150
L_COLOR1	= $9C
L_COLOR2	= $12
L_COLOR4	= $12
CS	= DATAORIGIN+$01D7
adr.FINALFNAME	= [DATAORIGIN+$01D9] .array [17]
.var FINALFNAME	= adr.FINALFNAME .word
@exit

@halt	ldx #$00
	txs
	.ifdef MAIN.@DEFINES.ROMOFF
	inc portb
	.fi

	ldy #$01

	rts

; ------------------------------------------------------------

IOCB@COPY	:16 brk

; ------------------------------------------------------------

.local	@DEFINES
ATARI
BASICOFF
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	.fi

	.ifdef MAIN.JOYSTICK.@UnitInit
	jsr MAIN.JOYSTICK.@UnitInit
	.fi

	.ifdef MAIN.MATH.@UnitInit
	jsr MAIN.MATH.@UnitInit
	.fi

	.ifdef MAIN.PMG.@UnitInit
	jsr MAIN.PMG.@UnitInit
	.fi

	.ifdef MAIN.XBIOS.@UnitInit
	jsr MAIN.XBIOS.@UnitInit
	.fi

	.ifdef MAIN.XBAPLIB.@UnitInit
	jsr MAIN.XBAPLIB.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi

	.ifdef MAIN.CIO.@UnitInit
	jsr MAIN.CIO.@UnitInit
	.fi

	.ifdef MAIN.APLIB.@UnitInit
	jsr MAIN.APLIB.@UnitInit
	.fi

	.ifdef MAIN.B_UTILS.@UnitInit
	jsr MAIN.B_UTILS.@UnitInit
	.fi

	.ifdef MAIN.MISC.@UnitInit
	jsr MAIN.MISC.@UnitInit
	.fi

	.ifdef MAIN.RMT.@UnitInit
	jsr MAIN.RMT.@UnitInit
	.fi

	.ifdef MAIN.B_PMG.@UnitInit
	jsr MAIN.B_PMG.@UnitInit
	.fi

	.ifdef MAIN.DOS.@UnitInit
	jsr MAIN.DOS.@UnitInit
	.fi

	.ifdef MAIN.STRUTILS.@UnitInit
	jsr MAIN.STRUTILS.@UnitInit
	.fi

	.ifdef MAIN.SYSUTILS.@UnitInit
	jsr MAIN.SYSUTILS.@UnitInit
	.fi

	.ifdef MAIN.B_SYSTEM.@UnitInit
	jsr MAIN.B_SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.B_CRT.@UnitInit
	jsr MAIN.B_CRT.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.JOYSTICK) > 0
	.print 'JOYSTICK: ',MAIN.JOYSTICK,'..',MAIN.JOYSTICK+.SIZEOF(MAIN.JOYSTICK)-1
	eif

	ift .SIZEOF(MAIN.MATH) > 0
	.print 'MATH: ',MAIN.MATH,'..',MAIN.MATH+.SIZEOF(MAIN.MATH)-1
	eif

	ift .SIZEOF(MAIN.PMG) > 0
	.print 'PMG: ',MAIN.PMG,'..',MAIN.PMG+.SIZEOF(MAIN.PMG)-1
	eif

	ift .SIZEOF(MAIN.XBIOS) > 0
	.print 'XBIOS: ',MAIN.XBIOS,'..',MAIN.XBIOS+.SIZEOF(MAIN.XBIOS)-1
	eif

	ift .SIZEOF(MAIN.XBAPLIB) > 0
	.print 'XBAPLIB: ',MAIN.XBAPLIB,'..',MAIN.XBAPLIB+.SIZEOF(MAIN.XBAPLIB)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

	ift .SIZEOF(MAIN.CIO) > 0
	.print 'CIO: ',MAIN.CIO,'..',MAIN.CIO+.SIZEOF(MAIN.CIO)-1
	eif

	ift .SIZEOF(MAIN.APLIB) > 0
	.print 'APLIB: ',MAIN.APLIB,'..',MAIN.APLIB+.SIZEOF(MAIN.APLIB)-1
	eif

	ift .SIZEOF(MAIN.B_UTILS) > 0
	.print 'B_UTILS: ',MAIN.B_UTILS,'..',MAIN.B_UTILS+.SIZEOF(MAIN.B_UTILS)-1
	eif

	ift .SIZEOF(MAIN.MISC) > 0
	.print 'MISC: ',MAIN.MISC,'..',MAIN.MISC+.SIZEOF(MAIN.MISC)-1
	eif

	ift .SIZEOF(MAIN.RMT) > 0
	.print 'RMT: ',MAIN.RMT,'..',MAIN.RMT+.SIZEOF(MAIN.RMT)-1
	eif

	ift .SIZEOF(MAIN.B_PMG) > 0
	.print 'B_PMG: ',MAIN.B_PMG,'..',MAIN.B_PMG+.SIZEOF(MAIN.B_PMG)-1
	eif

	ift .SIZEOF(MAIN.DOS) > 0
	.print 'DOS: ',MAIN.DOS,'..',MAIN.DOS+.SIZEOF(MAIN.DOS)-1
	eif

	ift .SIZEOF(MAIN.STRUTILS) > 0
	.print 'STRUTILS: ',MAIN.STRUTILS,'..',MAIN.STRUTILS+.SIZEOF(MAIN.STRUTILS)-1
	eif

	ift .SIZEOF(MAIN.SYSUTILS) > 0
	.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
	eif

	ift .SIZEOF(MAIN.B_SYSTEM) > 0
	.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.B_CRT) > 0
	.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $02 $08  $80 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 <[CODEORIGIN+$0003] >[CODEORIGIN+$0003] $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $1F $1C $1F  $1E $1F $1E $1F $1F $1E $1F $1E
.by  $1F $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $0E

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 490

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	run START

; ------------------------------------------------------------

.macro	STATICDATA
.by  $00 $00 $40 $41 $42 $43 $44 $45  $46 $47 $48 $49 $4A $4B $4C $4D  $4E $4F $50 $51 $52 $53 $54 $55
.by  $56 $57 $58 $59 $5A $61 $62 $63  $64 $65 $66 $67 $68 $69 $6A $6B  $6C $6D $6E $6F $70 $71 $72 $73
.by  $74 $75 $76 $77 $78 $79 $7A $30  $31 $32 $33 $34 $35 $36 $37 $38  $39 $2B $2F $00 $04 $54 $52 $55
.by  $45 $00 $05 $46 $41 $4C $53 $45  $00 $0B $4C $4F $47 $4F $20 $20  $20 $20 $41 $50 $4C $00 $09 $2E
.by  $2F $00 $38 $22 $29 $2F $33 $01  $00 $0B $4D $41 $49 $4E $20 $20  $20 $20 $58 $45 $58 $00 $6C $6A
.by  $3B $FF $FF $6B $2B $2A $6F $FF  $70 $75 $9B $69 $2D $3D $76 $FF  $63 $FF $FF $62 $78 $7A $34 $FF
.by  $33 $36 $1B $35 $32 $31 $2C $20  $2E $6E $FF $6D $2F $81 $72 $FF  $65 $79 $7F $74 $77 $71 $39 $FF
.by  $30 $37 $7E $38 $3E $FF $66 $68  $64 $FF $82 $67 $73 $61 $4C $4A  $3A $FF $FF $4B $5C $5E $4F $FF
.by  $50 $55 $FF $49 $5F $7C $56 $FF  $43 $FF $FF $42 $58 $5A $24 $FF  $23 $26 $FF $25 $22 $21 $5B $3B
.by  $5D $4E $FF $4D $3F $FF $52 $FF  $45 $59 $FF $54 $57 $51 $28 $FF  $29 $27 $FF $40 $FF $FF $46 $48
.by  $44 $FF $FF $47 $53 $41 $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF
.endm

	end
